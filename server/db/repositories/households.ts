import type {
  HouseholdDto,
  HouseholdInsertDto,
  HouseholdUserDto,
  HouseholdUserInsertDto,
  HouseholdWithUsersNamesDto,
} from "@/types/dto/household";

import { and, eq, sql } from "drizzle-orm";

import { getUsersByIds } from "./users";

import { db } from "@/server/db/drizzle";
import { households, householdUsers } from "@/server/db/schema";
import {
  HouseholdInsertBaseSchema,
  HouseholdSelectBaseSchema,
  HouseholdUserInsertBaseSchema,
  HouseholdWithUsersNamesSchema,
} from "@/server/db/zodSchemas/household";

export async function getUsersByHouseholdId(householdId: string): Promise<HouseholdUserDto[]> {
  const rows = await db.query.householdUsers.findMany({
    where: eq(householdUsers.householdId, householdId),
  });

  return rows;
}

export async function createHousehold(input: HouseholdInsertDto): Promise<HouseholdDto> {
  const parsed = HouseholdInsertBaseSchema.safeParse(input);

  if (!parsed.success) throw new Error("Invalid HouseholdInsertDto");

  // generate a unique 6-digit code with 10-minute expiration
  const code = await generateUniqueJoinCode();
  const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

  const [row] = await db
    .insert(households)
    .values({ ...parsed.data, joinCode: code, joinCodeExpiresAt: expiresAt })
    .returning();
  const validated = HouseholdSelectBaseSchema.safeParse(row);

  if (!validated.success) throw new Error("Failed to parse created household");

  return validated.data;
}

export async function deleteHousehold(id: string): Promise<void> {
  await db.delete(households).where(eq(households.id, id));
}

export async function getHouseholdById(id: string): Promise<HouseholdDto | null> {
  const rows = await db.select().from(households).where(eq(households.id, id)).limit(1);
  const parsed = HouseholdSelectBaseSchema.safeParse(rows[0]);

  return parsed.success ? parsed.data : null;
}

/**
 * Get the single household for a user
 * Users are only allowed to be in one household at a time
 */
export async function getHouseholdForUser(
  userId: string
): Promise<HouseholdWithUsersNamesDto | null> {
  const rows = (await db.query.householdUsers.findFirst({
    where: eq(householdUsers.userId, userId),
    columns: { householdId: true },
    with: {
      household: {
        columns: {
          id: true,
          name: true,
          adminUserId: true,
          createdAt: true,
          updatedAt: true,
          joinCode: true,
          joinCodeExpiresAt: true,
        },
        with: {
          users: {
            columns: { userId: true },
          },
        },
      },
    },
  })) as any;

  if (!rows?.household) return null;

  const h = rows.household;
  const allUserIds = (h.users ?? []).map((m: any) => m.userId);

  const usersRows = await getUsersByIds(allUserIds);

  const idToName = new Map(usersRows.map((u) => [u.id, u.name]));

  const mapped = {
    id: h.id,
    name: h.name,
    adminUserId: h.adminUserId,
    createdAt: h.createdAt,
    updatedAt: h.updatedAt,
    joinCode: h.joinCode,
    joinCodeExpiresAt: h.joinCodeExpiresAt,
    users: allUserIds.map((uid: string) => ({
      id: uid,
      name: idToName.get(uid) ?? null,
      isAdmin: uid === h.adminUserId,
    })),
  };

  const parsed = HouseholdWithUsersNamesSchema.safeParse(mapped);

  if (!parsed.success) throw new Error("Failed to parse household for user");

  return parsed.data;
}

/**
 * Gets all member IDs in the user's household (including the user)
 * If user is not in a household, returns just the user's ID
 */
export async function getHouseholdMemberIds(userId: string): Promise<string[]> {
  const household = await getHouseholdForUser(userId);
  const memberIds = Array.from(new Set([userId, ...(household?.users.map((u) => u.id) ?? [])]));

  return memberIds;
}

export async function addUserToHousehold(input: HouseholdUserInsertDto): Promise<HouseholdUserDto> {
  const parsed = HouseholdUserInsertBaseSchema.safeParse(input);

  if (!parsed.success) throw new Error("Invalid HouseholdUserInsertDto");

  // Check if user is already in a household
  const existingHousehold = await getHouseholdForUser(parsed.data.userId);

  if (existingHousehold) {
    throw new Error("User is already in a household. Leave the current household first.");
  }

  const [row] = await db
    .insert(householdUsers)
    .values(parsed.data as any)
    .onConflictDoNothing()
    .returning();

  const resolved = row
    ? row
    : (
        await db
          .select()
          .from(householdUsers)
          .where(
            and(
              eq(householdUsers.householdId, parsed.data.householdId),
              eq(householdUsers.userId, parsed.data.userId)
            )
          )
          .limit(1)
      )[0];

  const validated = HouseholdUserInsertBaseSchema.safeParse(resolved);

  if (!validated.success) throw new Error("Failed to add user to household");

  return validated.data as HouseholdUserDto;
}

export async function removeUserFromHousehold(householdId: string, userId: string): Promise<void> {
  await db.transaction(async (tx) => {
    await tx
      .delete(householdUsers)
      .where(and(eq(householdUsers.householdId, householdId), eq(householdUsers.userId, userId)));

    const rows = await tx
      .select({ count: sql<number>`count(*)` })
      .from(householdUsers)
      .where(eq(householdUsers.householdId, householdId));

    const count = Number(rows?.[0]?.count ?? 0);

    if (count === 0) {
      await tx.delete(households).where(eq(households.id, householdId));
    }
  });
}

export async function findHouseholdByJoinCode(code: string): Promise<HouseholdDto | null> {
  const rows = await db
    .select()
    .from(households)
    .where(eq(households.joinCode as any, code))
    .limit(1);
  const parsed = HouseholdSelectBaseSchema.safeParse(rows[0]);

  return parsed.success ? parsed.data : null;
}

export async function joinHouseholdByCode(
  userId: string,
  code: string
): Promise<HouseholdUserDto | null> {
  const household = await findHouseholdByJoinCode(code);

  if (!household) return null;

  return addUserToHousehold({ householdId: household.id, userId });
}

/**
 * Regenerates the join code for a household with a new 10-minute expiration
 */
export async function regenerateJoinCode(householdId: string): Promise<HouseholdDto> {
  const code = await generateUniqueJoinCode();
  const expiresAt = new Date(Date.now() + 10 * 60 * 1000); // 10 minutes

  const [row] = await db
    .update(households)
    .set({ joinCode: code, joinCodeExpiresAt: expiresAt, updatedAt: new Date() })
    .where(eq(households.id, householdId))
    .returning();

  const validated = HouseholdSelectBaseSchema.safeParse(row);

  if (!validated.success) throw new Error("Failed to regenerate join code");

  return validated.data;
}

/**
 * Checks if a user is the admin of a household
 */
export async function isUserHouseholdAdmin(householdId: string, userId: string): Promise<boolean> {
  const household = await getHouseholdById(householdId);

  return household?.adminUserId === userId;
}

/**
 * Kicks a user from a household (admin only)
 */
export async function kickUserFromHousehold(
  householdId: string,
  userIdToKick: string,
  adminUserId: string
): Promise<void> {
  // Verify admin
  const isAdmin = await isUserHouseholdAdmin(householdId, adminUserId);

  if (!isAdmin) {
    throw new Error("Only the household admin can kick members");
  }

  // Cannot kick yourself
  if (userIdToKick === adminUserId) {
    throw new Error("Admin cannot kick themselves. Transfer admin first or leave the household.");
  }

  await removeUserFromHousehold(householdId, userIdToKick);
}

/**
 * Transfers admin privileges to another member
 */
export async function transferHouseholdAdmin(
  householdId: string,
  currentAdminId: string,
  newAdminId: string
): Promise<HouseholdDto> {
  // Verify current admin
  const isAdmin = await isUserHouseholdAdmin(householdId, currentAdminId);

  if (!isAdmin) {
    throw new Error("Only the current admin can transfer admin privileges");
  }

  // Verify new admin is a member
  const members = await getUsersByHouseholdId(householdId);
  const isMember = members.some((m) => m.userId === newAdminId);

  if (!isMember) {
    throw new Error("New admin must be a member of the household");
  }

  const [row] = await db
    .update(households)
    .set({ adminUserId: newAdminId, updatedAt: new Date() })
    .where(eq(households.id, householdId))
    .returning();

  const validated = HouseholdSelectBaseSchema.safeParse(row);

  if (!validated.success) throw new Error("Failed to transfer admin");

  return validated.data;
}

async function generateUniqueJoinCode(): Promise<string> {
  while (true) {
    const code = Math.floor(Math.random() * 1_000_000)
      .toString()
      .padStart(6, "0");

    const existing = await db
      .select({ id: households.id })
      .from(households)
      .where(eq(households.joinCode as any, code))
      .limit(1);

    if (existing.length === 0) return code;
  }
}
